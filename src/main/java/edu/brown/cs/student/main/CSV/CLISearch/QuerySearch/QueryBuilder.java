package edu.brown.cs.student.main.CSV.CLISearch.QuerySearch;


import edu.brown.cs.student.main.CSV.CLISearch.QuerySearch.Exceptions.SearchArgumentException;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.List;

public class QueryBuilder {
    //constants
    static final String AND = "and";
    static final String OR = "or";
    static final String NOT = "not";
    static final String COLUMN = "col";
    static final String BASIC = "";

    private Query builtQuery;
    private List<List<String>> pool;
    private String text;

    public QueryBuilder() {

    }

    public QueryBuilder(String text) {
        this.text = text;
    }

    public Query build() {
        //read until (
        String[] parts = this.text.split("[(]" );
//        System.out.println(Arrays.toString(parts));
        String keyword = parts[0];

        String insideText = null;
        try {
            insideText = getTextBetweenParentheses(this.text);
        } catch (SearchArgumentException e) {
            throw new RuntimeException(e);
        }

//        System.out.println("keyword: " +keyword);
        switch (keyword) {
            case AND -> this.builtQuery = new AndQuery(insideText);
            case OR -> this.builtQuery = new OrQuery(insideText);
            case NOT -> this.builtQuery = new NotQuery(insideText);
            case COLUMN -> this.builtQuery = new ColumnQuery(insideText);
            default -> this.builtQuery = new BasicQuery(insideText);
//            default -> throw new IllegalStateException("Unexpected value: " + keyword);
        }
        System.out.println("Query has been built with "+insideText);
        return this.builtQuery;

    }


    public Query getBuiltQuery() {
        return builtQuery;
    }

    //generated by me
    public String getTextBetweenParentheses(String input) throws SearchArgumentException {

        // if there are no parentheses, return the input
        if (!text.matches(".*[\\(\\)].*")) {
            return input;
        }

        StringBuilder result = new StringBuilder(); //adds characters to the string
        Deque<Character> stack = new ArrayDeque<>(); //holds the parentheses

        boolean insideParentheses = false;

        for (char c : input.toCharArray()) {

            if (c == '(') {
                if (!stack.isEmpty()) { // && stack.peek() == '\'') {
                    result.append(c);
                }
                stack.push(c);
                insideParentheses = true;
            } else if (c == ')') {
                stack.pop();
                if (!stack.isEmpty()) {
                    result.append(c);
                } else {
                    insideParentheses = false;
                }

            } else {
                if (insideParentheses) {
                    result.append(c);
                }
            }
        }

        // if the stack is not empty, throw error
        if (!stack.isEmpty()) {
            throw new SearchArgumentException("ERROR: Parentheses are not balanced.");
        }

        return result.toString();
    }


}


