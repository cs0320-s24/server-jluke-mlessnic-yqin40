package edu.brown.cs.student.main.CSV.CLISearch.QuerySearch;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.List;

public class QueryBuilder {
    //constants
    static final String AND = "and";
    static final String OR = "or";
    static final String NOT = "not";
    static final String COLUMN = "col";
    static final String BASIC = "";

    private Query builtQuery;
    private List<List<String>> pool;
    private String text;

    public QueryBuilder() {

    }

    public QueryBuilder(String text) {
        this.text = text;
    }

    public Query build() {
        //read until (
        String[] parts = this.text.split("\\([^(]*\\)");
        String keyword = parts[0];

        String insideText = getTextBetweenParentheses(this.text);

        switch (keyword) {
            case AND -> this.builtQuery = new AndQuery(insideText);
            case OR -> this.builtQuery = new OrQuery(insideText);
            case NOT -> this.builtQuery = new NotQuery(insideText);
            case COLUMN -> this.builtQuery = new ColumnQuery(insideText);
            default -> this.builtQuery = new BasicQuery(insideText);
//            default -> throw new IllegalStateException("Unexpected value: " + keyword);
        }
        System.out.println("Query has been built with "+insideText);
        return this.builtQuery;

    }


    public Query getBuiltQuery() {
        return builtQuery;
    }

    //generated by chat gpt
    public String getTextBetweenParentheses(String input) {

        if (!text.matches(".*[\\(\\)].*")) {
            return input;
        }

        StringBuilder result = new StringBuilder();
        Deque<Character> stack = new ArrayDeque<>();

        boolean insideParentheses = false;

        for (char c : input.toCharArray()) {
            if (c == '(') {
                if (!stack.isEmpty() && stack.peek() == '\'') {
                    result.append(c);
                } else {
                    stack.push(c);
                    insideParentheses = true;
                }
            } else if (c == ')') {
                if (!stack.isEmpty() && stack.peek() == '\'') {
                    result.append(c);
                } else {
                    stack.pop();
                    if (stack.isEmpty()) {
                        insideParentheses = false;
                    }
                }
            } else {
                if (insideParentheses) {
                    result.append(c);
                }
            }
        }

        return result.toString();
    }


}





//package edu.brown.cs.student.main.CLISearch.QuerySearch;
//
//import java.util.Stack;
//
//public class QueryBuilder {
//
//    public static final String AND = "and";
//    public static final String OR = "or";
//    public static final String NOT = "not";
//    public static final String IN = "in";
//
//
////    String arg;
////
////    public QueryBuilder(String arg) {
////        this.arg = arg;
////    }
//
//    public Query build() {
//        //and(name(1, "col2"), 7)
//
//    }
//
//    private void parseBetweenParentheses(int startingIndex)  {
//        // Step through the string character by character
//
//        while (startingIndex < this.arg.length()) {
//            char ch = str.charAt(i);
//            if (ch = '(') {
//                String inside
//            }
//
//        }
//    }
////chat gpt
//    private static boolean areParenthesesBalanced(String str) {
//        Stack<Character> stack = new Stack<>();
//
//        for (char ch : str.toCharArray()) {
//            if (ch == '(') {
//                stack.push(ch);
//            } else if (ch == ')') {
//                if (stack.isEmpty() || stack.pop() != '(') {
//                    return false; // Unbalanced parentheses
//                }
//            }
//        }
//
//        return stack.isEmpty(); // If stack is empty, parentheses are balanced
//    }
//
//    private String getStringBetweenParentheses(String str) {
//        if (!areParentheseBalanced(str)) {
//            //throw error
//            return null;
//        }
//        Stack<Character> stack = new Stack<>();
//        StringBuilder sb = new StringBuilder();
//
//        for (char ch : str.toCharArray()) {
//            if (ch == '(') {
//                stack.push(ch);
//            } else if (ch == ')') {
//                if (stack.isEmpty() || stack.pop() != '(') {
//                    sb.append(ch);
//                }
//            }
//        }
//
//        if (stack.isEmpty()) { // If stack is empty, parentheses are balanced
//            String inside = sb.toString();
//            if (containsParentheses(inside)) {
//                this.getStringBetweenParentheses(inside); //recursive
//            } else {
//
//            }
//
//        } else {
//            //error, parentheses unbalanced
//            return null;
//        }
//    }
//
//    private boolean containsParentheses(String str) {
//        return str.contains("(") || str.contains(")");
//
//    }
//
//
//
//}
